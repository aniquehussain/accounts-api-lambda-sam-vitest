{
  "version": 3,
  "sources": ["../../../../../../../../private/tmp/tmpq6zh3qor/app.ts"],
  "sourcesContent": ["import { DynamoDBClient } from \"@aws-sdk/client-dynamodb\";\nimport {\n  DynamoDBDocumentClient,\n  GetCommand,\n  PutCommand,\n  ScanCommand,\n  UpdateCommand,\n} from \"@aws-sdk/lib-dynamodb\";\nimport { v4 } from \"uuid\";\nimport { APIGatewayProxyEvent } from \"aws-lambda\";\n\nconst Users = \"Users\";\nconst Transactions = \"Transactions\";\n\ntype User = {\n  userId: string;\n  name: string;\n  balance: number;\n};\n\ntype Transaction = {\n  userId: string;\n  transactionId: string;\n  amount: number;\n  type: string;\n  createdAt: string;\n};\n\ntype Response = {\n  statusCode: number;\n  body: any;\n};\n// Create a DynamoDB client\nconst client = new DynamoDBClient({});\nconst ddbDocClient = DynamoDBDocumentClient.from(client);\n\n// Initialize the Lambda function\nexport const lambdaHandler = async (event: APIGatewayProxyEvent) => {\n  \n  // check if client is initialized\n  if (!ddbDocClient) {\n    throw new Error(\"DynamoDB client not initialized\");\n  }\n  \n  // Initialize the response\n  let response: Response = {\n    statusCode: 200,\n    body: { message: \"\" },\n  };\n\n  // Get the HTTP method\n  let httpRequest = event.httpMethod as string;\n\n  // Parse the request body\n  const body = JSON.parse(event.body as string);\n\n  // Get the userId, amount, and type from the request body\n  const { userId, amount, type } = body;\n  try {\n    // Switch on the HTTP method\n    switch (httpRequest) {\n      //  If the request is a POST request\n      case \"POST\":\n        if (!userId) { \n          throw new Error(\"User ID is required\");\n        }\n        // Get the user's balance\n        const user: User = await getUser(ddbDocClient, userId) as User;\n        const balance: number = user?.balance || 0;\n\n        // Return the user's balance\n        response = {\n          statusCode: 200,\n          body: JSON.stringify({\n            message: \"User balance retrieved successfully\",\n            balance: balance,\n          }),\n        };\n        break;\n\n      // If the request is a PATCH request\n      case \"PATCH\":\n        // Check if the transaction type is valid\n        if (type !== \"debit\" && type !== \"credit\") {\n          throw new Error(\n            \"Invalid transaction type. Must be 'debit' or 'credit'.\"\n          );\n        }\n        // Check if the amount is valid\n        if (!amount) { \n          throw new Error(\"Amount is required\");\n        } \n\n        // Check if the amount is a valid number\n        if (isNaN(parseFloat(amount)) || !isFinite(amount) || parseFloat(amount) <= 0){\n          throw new Error(\"Invalid amount\");\n        }\n\n        // Create a new transaction\n        const transactionId = v4();\n\n        // Prepare the transaction object\n        const transaction: Transaction = {\n          userId,\n          transactionId,\n          amount: parseFloat(amount),\n          type,\n          createdAt: new Date().toISOString(),\n        };\n\n        // Make the transaction\n        await transact(ddbDocClient, transaction);\n\n        // Return the response\n        response = {\n          statusCode: 200,\n          body: JSON.stringify({\n            message: \"Transaction successful\",\n            transactionId: transaction.transactionId,\n            type,\n          }),\n        };\n        break;\n\n      // If the request is a PUT request\n      case \"PUT\":\n        // Check if the user's name is valid\n        if (!body.name) {\n          throw new Error(\"Name is required\");\n        }\n        // Prepare the user object\n        const userBody = {\n          name: body.name,\n          userId: v4(),\n          balance: 100,\n        };\n\n        // Add the user to the Users table\n        await createUser(ddbDocClient, userBody);\n\n        // Return the response\n        response = {\n          statusCode: 200,\n          body: JSON.stringify({\n            message: \"User created successfully\",\n            userId: userBody.userId,\n          }),\n        };\n        break;\n\n      default:\n        // If the request is invalid, return an error\n        response = {\n          statusCode: 400,\n          body: \"Invalid request\",\n        };\n        break;\n    }\n  } catch (err: any) {\n    // If there's an error, return the error message\n    response = {\n      statusCode: 400,\n      body: err.message,\n    };\n  } finally {\n    // Return the response object and destroy the client\n    ddbDocClient.destroy();\n    return response;\n  }\n};\n\n// Function to create a user\nconst createUser = async (dbClient: typeof ddbDocClient, user: User) => {\n  //check if user exists\n  const users: User[] = await getAllUsers(dbClient) as User[];\n  // Check if the user already exists\n  const userExists = users.some((u: User) => u.userId === user.userId);\n  if (userExists) {\n    throw new Error(\"User already exists\");\n  }\n  // Prepare the parameters\n  let params = {\n    TableName: Users,\n    Item: user,\n  };\n\n  // Add the user to the Users table\n  return await dbClient.send(new PutCommand(params));\n};\n\n// Function to get all users\nconst getAllUsers = async (dbClient: typeof ddbDocClient) => {\n  let params = {\n    TableName: Users,\n  };\n  const data = await dbClient.send(new ScanCommand(params));\n  return data.Items;\n};\n\n// Function to get a user\nconst getUser = async (dbClient: typeof ddbDocClient, userId: string) => {\n  let params = {\n    TableName: Users,\n    Key: { userId: userId },\n  };\n  const data = await dbClient.send(new GetCommand(params));\n  return data.Item;\n};\n\n// Function to make a transaction\nconst transact = async (\n  dbClient: typeof ddbDocClient,\n  transaction: Transaction\n) => {\n  // Check for idempotency\n  const isIdempotent: boolean = await checkIdempotency(dbClient, transaction);\n\n  // If the transaction is idempotent, skip it\n  if (isIdempotent) {\n    console.log(\n      `Transaction with ID ${transaction.transactionId} is idempotent. Skipping.`\n    );\n    return;\n  }\n\n  // Put the transaction into DynamoDB\n  let params: any = {\n    TableName: Transactions,\n    Item: transaction,\n  };\n\n  // Add the transaction to the Transactions table\n  await dbClient.send(new PutCommand(params));\n\n  // Update the user's balance\n  const user: User = await getUser(dbClient, transaction.userId) as User;\n\n  // Check if the user has sufficient funds for a debit transaction\n  if (transaction.type === \"debit\" && user.balance - transaction.amount < 0)\n    throw new Error(\"Insufficient funds\");\n\n  // Calculate the new balance\n  const newBalance =\n    transaction.type === \"debit\"\n      ? user.balance - transaction.amount\n      : user.balance + transaction.amount;\n\n  // Prepare the update parameters\n  params = {\n    TableName: Users,\n    Key: { userId: transaction.userId },\n    UpdateExpression: \"set balance = :balance\",\n    ExpressionAttributeValues: {\n      \":balance\": newBalance,\n    },\n    ReturnValues: \"UPDATED_NEW\",\n  };\n\n  // Update the user's balance\n  await dbClient.send(new UpdateCommand(params));\n};\n\nconst checkIdempotency = async (\n  dbClient: typeof ddbDocClient,\n  transaction: Transaction\n) => {\n  // Check if the transactionId exists in the Transactions table\n  // If it does, the transaction is idempotent\n\n  let params = {\n    TableName: Transactions,\n    Key: {\n      transactionId: transaction.transactionId,\n      userId: transaction.userId,\n    },\n  };\n\n  const data = await dbClient.send(new GetCommand(params));\n  return !!data.Item; // Returns true if the transactionId is found, indicating idempotency\n};\n"],
  "mappings": "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",
  "names": []
}
